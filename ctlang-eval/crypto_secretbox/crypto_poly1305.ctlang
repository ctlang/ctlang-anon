// using 64-bit implementation (poly1305_donna64.h)
// #define poly1305_block_size 16
struct poly1305_state_internal_t {
    secret uint64[3] r;
    secret uint64[3] h;
    secret uint64[2] pad;
    public uint64 leftover;
    secret uint8[16] buffer; // poly1305_block_size
    secret uint8 final;
}

void _poly1305_blocks(
    mut poly1305_state_internal_t state,
    secret uint8[] m) {
  public uint64 mask44 = 0xfffffffffff;
  public uint64 mask42 = 0x3ffffffffff;

  secret uint64 hibit = (state.final != 0) ? 0 : (uint64(1) << 40);

  secret uint64 r0 = state.r[0];
  secret uint64 r1 = state.r[1];
  secret uint64 r2 = state.r[2];

  secret mut uint64 h0 = state.h[0];
  secret mut uint64 h1 = state.h[1];
  secret mut uint64 h2 = state.h[2];

  secret uint64 s1 = r1 * (5 << 2);
  secret uint64 s2 = r2 * (5 << 2);

  public uint64 mloops = len m / 16;
  for (uint64 bindex from 0 to mloops) {
    secret uint64 t0 = load_le(view(m, bindex * 16, 8));
    secret uint64 t1 = load_le(view(m, bindex * 16 + 8, 8));

    /* h += m[i] */
    // this is clearly some sort of odd-bit add-with-carry
    h0 += ((t0) & mask44);
    h1 += (((t0 >> 44) | (t1 << 20)) & mask44);
    h2 += (((t1 >> 24)) & mask42) | hibit;

    /* h *= r */
    secret mut uint128 d0 = (uint128(h0) * r0) + (uint128(h1) * s2) + (uint128(h2) * s1);
    secret mut uint128 d1 = (uint128(h0) * r1) + (uint128(h1) * r0) + (uint128(h2) * s2);
    secret mut uint128 d2 = (uint128(h0) * r2) + (uint128(h1) * r1) + (uint128(h2) * r0);

    /* (partial) h %= p */
    secret mut uint64 c = uint64(d0 >> 44);
    h0 = uint64(d0) & mask44;
    d1 += c;
    c = uint64(d1 >> 44);
    h1 = uint64(d1) & mask44;
    d2 += c;
    c = uint64(d2 >> 42);
    h2 = uint64(d2) & mask42;
    h0 += c * 5;
    c = uint64(h0 >> 44);
    h0 &= mask44;
    h1 += c;
  }

  state.h[0] = h0;
  state.h[1] = h1;
  state.h[2] = h2;
}

void _poly1305_init(
    mut poly1305_state_internal_t state,
    secret uint8[32] key) {
  /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */
  secret uint64 t0 = load_le(view(key, 0, 8));
  secret uint64 t1 = load_le(view(key, 8, 8));

  /* wiped after finalization */
  state.r[0] = (t0) & 0xffc0fffffff;
  state.r[1] = ((t0 >> 44) | (t1 << 20)) & 0xfffffc0ffff;
  state.r[2] = ((t1 >> 24)) & 0x00ffffffc0f;

  /* h = 0 */
  state.h[0] = 0;
  state.h[1] = 0;
  state.h[2] = 0;

  /* save pad for later */
  state.pad[0] = load_le(view(key, 16, 8));
  state.pad[1] = load_le(view(key, 24, 8));

  state.leftover = 0;
  state.final = 0;
}

void _poly1305_update(
    mut poly1305_state_internal_t state,
    secret uint8[] m) {
  public mut uint64 mindex = 0;

  /* handle leftover */
  if (state.leftover != 0) {
    public mut uint64 want = 16 - state.leftover;
    if (want > len m) {
      want = len m;
    }

    for (uint64 i from 0 to want) {
      public uint64 index = state.leftover + i;
      assume(index < len state.buffer);
      assume(i < len m);
      state.buffer[index] = m[i];
    }
    mindex += want;
    state.leftover += want;
    if (state.leftover < 16) {
      return;
    }
    _poly1305_blocks(state, state.buffer);
    state.leftover = 0;
  }

  /* process full blocks */
  if (len m - mindex >= 16) {
    public uint64 want = ((len m - mindex) & ~(uint64(16 - 1))); // XXX wat

    public uint64 _mindex = mindex;
    assume(_mindex < _mindex + want);
    assume(_mindex + want <= len m);
    secret uint8[] mview = view(m, _mindex, want);
    _poly1305_blocks(state, mview);
    mindex += want;
  }

  /* store leftover */
  if (mindex < len m) {
    public uint64 remaining = len m - mindex;
    for (uint64 i from 0 to remaining) {
      public uint64 _leftover = state.leftover;
      public uint64 _mindex = mindex;
      assume(_leftover + i < len state.buffer);
      assume(_mindex + i < len m);
      state.buffer[_leftover + i] = m[_mindex + i];
    }
    state.leftover += remaining;
  }
}

void _poly1305_finish(
    mut poly1305_state_internal_t state,
    secret mut uint8[16] mac) {
  /* process the remaining block */
  if (state.leftover != 0) {
    public uint64 start = state.leftover;
    assume(start < len state.buffer);
    state.buffer[start] = 1;
    for (uint64 i from start + 1 to 16) {
      state.buffer[i] = 0;
    }
    state.final = 1;
    _poly1305_blocks(state, state.buffer);
  }

  public uint64 mask44 = 0xfffffffffff;
  public uint64 mask42 = 0x3ffffffffff;

  /* fully carry h */
  secret mut uint64 h0 = state.h[0];
  secret mut uint64 h1 = state.h[1];
  secret mut uint64 h2 = state.h[2];

  secret mut uint64 c = h1 >> 44;
  h1 &= mask44;
  h2 += c;
  c = h2 >> 42;
  h2 &= mask42;
  h0 += c * 5;
  c = h0 >> 44;
  h0 &= mask44;
  h1 += c;
  c = h1 >> 44;
  h1 &= mask44;
  h2 += c;
  c = h2 >> 42;
  h2 &= mask42;
  h0 += c * 5;
  c = h0 >> 44;
  h0 &= mask44;
  h1 += c;

  /* compute h + -p */
  secret mut uint64 g0 = h0 + 5;
  c = g0 >> 44;
  g0 &= mask44;
  secret mut uint64 g1 = h1 + c;
  c = g1 >> 44;
  g1 &= mask44;
  secret mut uint64 g2 = h2 + c - (uint64(1) << 42);

  /* select h if h < p, or h + -p if h >= p */
  c = (g2 >> ((8 * 8) - 1)) - 1;
  g0 &= c;
  g1 &= c;
  g2 &= c;
  c = ~c;
  h0 = (h0 & c) | g0;
  h1 = (h1 & c) | g1;
  h2 = (h2 & c) | g2;

  /* h = (h + pad) */
  secret uint64 t0 = state.pad[0];
  secret uint64 t1 = state.pad[1];

  h0 += t0 & mask44;
  c = h0 >> 44;
  h0 &= mask44;
  h1 += (((t0 >> 44) | (t1 << 20)) & mask44) + c;
  c = h1 >> 44;
  h1 &= mask44;
  h2 += (((t1 >> 24)) & mask42) + c;
  h2 &= mask42;

  /* mac = h % (2^128) */
  h0 = (h0 | (h1 << 44));
  h1 = ((h1 >> 20) | (h2 << 24));

  store_le(view(mac, 0, 8), h0);
  store_le(view(mac, 8, 8), h1);

  /* zero out the state */
  smemzero(state);
}

public int32 _crypto_onetimeauth_poly1305( // crypto_onetimeauth_poly1305_donna from poly1305_donna.c
    secret mut uint8[16] out,
    secret uint8[] m,
    secret uint8[32] key) {
  mut poly1305_state_internal_t state = {
    r : zeros(3),
    h : zeros(3),
    pad : zeros(2),
    leftover : 0,
    buffer : zeros(16),
    final : 0
  };

  _poly1305_init(state, key);
  _poly1305_update(state, m);
  _poly1305_finish(state, out);
  return 0;
}

public bool _crypto_onetimeauth_poly1305_verify( // crypto_onetimeauth_poly1305_donna_verify from poly1305.c
    public uint8[16] h,
    public uint8[] input,
    secret uint8[32] k) {
  secret mut uint8[16] correct = zeros(16);
  _crypto_onetimeauth_poly1305(correct, input, k);
  return declassify(_crypto_verify_16(h, correct));
}
