extern void SHA1_Transform(secret mut uint8[216] ctx, secret uint8[] input); // `md_transform`
extern void _md_final_raw(secret mut uint8[216] ctx, secret uint8[] input); // `md_final_raw`

export secret int32 __ssl3_cbc_digest_record(
    secret mut uint8[216] md_state,
    secret mut uint8[64] mac_out,
    /* ~~~ */
    secret uint8[] header,
    secret uint8[] data,
    // `data_plus_mac_plus_padding_size` is len data
    secret uint64 data_plus_mac_size) {
  public uint32 MAX_HASH_BLOCK_SIZE = 128;
  public uint32 SIZEOF_LARGEST_DIGEST_CTX = 216; // idk just picking some arbitrary number
  public uint32 MAX_HASH_BIT_COUNT_BYTES = 16;
  public uint32 EVP_MAX_MD_SIZE = 64;

  public uint64 md_size =               20;
  public uint64 md_block_size =         64;
  public uint64 sslv3_pad_length =      40;
  public uint64 md_length_size =        8;


  // skipping the prequel stuff in the function since it doesn't really have any ct

  public uint64 variance_blocks = 2;
  public uint64 length = (len data) + (len header); // `len` in openssl but that's a keyword
  public uint64 max_mac_bytes = length - md_size - 1;
  public uint64 num_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size;
  secret uint64 mac_end_offset = data_plus_mac_size + (len header) - md_size;
  secret uint64 c = mac_end_offset % md_block_size;
  secret uint64 index_a = mac_end_offset / md_block_size;
  secret uint64 index_b = (mac_end_offset + md_length_size) / md_block_size;

  public mut uint64 num_starting_blocks = 0;
  public mut uint64 k = 0; // XXX is this really public?
  if (num_blocks > variance_blocks + 1) {
    num_starting_blocks = num_blocks - variance_blocks;
    k = md_block_size * num_starting_blocks;
  }
  assume(k == ((num_blocks > variance_blocks + 1) ? md_block_size * num_starting_blocks : 0));
  assume(len data >= k);
  assume(len header <= 2 * md_block_size);

  secret mut uint8[128] first_block = zeros(128); // `MAX_HASH_BLOCK_SIZE`

  secret uint64 bits = 8 * mac_end_offset;

  secret mut uint8[16] length_bytes = zeros(16); // `MAX_HASH_BIT_COUNT_BYTES`

  length_bytes[md_length_size - 4] = uint8(bits >> 24);
  length_bytes[md_length_size - 3] = uint8(bits >> 16);
  length_bytes[md_length_size - 2] = uint8(bits >> 8);
  length_bytes[md_length_size - 1] = uint8(bits);

  if (k > 0) {
    if ((len header) <= md_block_size) {
      // "Should never happen"
      return 0;
    }
    public uint64 overhang = (len header) - md_block_size;
    SHA1_Transform(md_state, header);
    memcpy(view(first_block, 0, overhang), view(header, md_block_size, overhang));
    public uint64 cpylen = md_block_size - overhang;
    memcpy(view(first_block, overhang, cpylen), view(data, 0, cpylen));
    SHA1_Transform(md_state, first_block);
    public uint64 loopbound = k / md_block_size - 1;
    for (uint64 i from 1 to loopbound) {
      public uint64 idx = md_block_size * i - overhang;
      SHA1_Transform(md_state, view(data, idx, md_block_size));
    }
  }

  for (uint64 i from num_starting_blocks to num_starting_blocks + variance_blocks + 1) {
    secret mut uint8[128] block = zeros(128); // `MAX_HASH_BLOCK_SIZE`
    secret bool is_block_a = (i == index_a);
    secret bool is_block_b = (i == index_b);
    for (uint64 j from 0 to md_block_size) {
      secret mut uint8 b = 0;
      public uint64 _k = k;
      if (_k < (len header)) {
        b = header[_k];
      } else if (_k < (len data) + (len header)) {
        b = data[_k - (len header)];
      }
      k += 1;

      secret bool is_past_c = is_block_a && (j >= c);
      secret bool is_past_cp1 = is_block_a && (j >= c + 1);
      b = is_past_c ? 0x80 : b;
      if (is_past_cp1) {
        b = 0;
      }
      if (is_block_b && (!is_block_a)) {
        b = 0;
      }
      if (j >= md_block_size - md_length_size) {
        b = is_block_b ? length_bytes[j - (md_block_size - md_length_size)] : b;
      }
      block[j] = b;
    }

    SHA1_Transform(md_state, block);
    _md_final_raw(md_state, block);

    for (uint64 j from 0 to md_size) {
      mac_out[j] |= is_block_b ? block[j] : 0;
    }
  }
  return 1;
}
